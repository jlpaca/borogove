<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>borogove</title>
    <style>
      *, *:before, *:after {
	  box-sizing: inherit;
      }
      body {
	  box-sizing: border-box;
	  margin: 0;
	  position: relative;

	  color: #ccc;
	  background-color: #f0f0f0;

	  min-height: 100vh;
	  
	  font-family: sans-serif;
      }
      .header {
	  position: fixed;
	  top: 0;

	  width: 100%;
	  height: 2em;
	  
	  display: table;
	  white-space: nowrap;
	  
	  border-bottom: 1px solid #ccc;
      }
      .header-content {
	  display: table-cell;
	  padding: 0 1em;
	  vertical-align: middle;
      }
      #text {
	  white-space: pre;

	  position: fixed;
	  top: 2em;
	  bottom: 1em;
	  overflow: scroll;
	  
	  width: 100%;
	  padding: 1em;
      }
      #text::selection {
	  background: #444;
	  color: #fff;
      }
      #text:focus {
	  outline: none;
	  color: #444;
      }
    </style>
    <script>

      let corpus = {
	  alice: [],
	  kjb: [],
	  dante: [],
      };
      /*
       for (let k in corpus) {
       fetch('http://localhost:8000/corpus/' + k + '.json')
       .then(resp => resp.json())
       .then(json => { corpus[k] = json; });	    
       }
      */
      corpus.toy = [
	  "THIS", "IS", "A", "CAT.",
	  "THIS", "IS", "NOT", "A", "BAT."
      ];
      
      function make_leaf () {
	  let el = Object.create(null);
	  el.total = 0;
	  el.next = Object.create(null);
	  return el;
      }

      function make_markov (lvl) {
	  let m = Object.create(null);
	  m.level = lvl;
	  m.tree = make_leaf();
	  return m;
      }

      function markov_push (m, arr) {
	  for (let i = m.level; i < arr.length; ++i) {
	      let node = m.tree;
	      let w;

	      for (j = i-m.level; j <= i; ++j) {
		  w = arr[j];
		  ++node.total;
		  node = (node.next[w] = node.next[w] || make_leaf());
	      }
	      ++node.total;
	  }
	  return m;
      }

      function markov_select (leaf) {
	  let r = Math.random() * leaf.total;
	  let s = 0;
	  for (let w in leaf.next) {
	      if ((s += leaf.next[w].total) > r) { return w; }
	  }
      }

      function markov_step (m, tail, depth) {
	  let len = tail.length;
	  if (depth === undefined) { depth = m.level; }
	  depth = Math.min(depth, len);

	  let node = m.tree;
	  let w;
	  for (let j = len - depth; j < len; ++j) {
	      w = tail[j];
	      if (!node.next[w]) {
		  /* if terminated; try with shorter inference */
		  return markov_step(m, tail, depth-1);
	      }
	      node = node.next[w];
	  }
	  tail.push(markov_select(node));
	  return tail;
      }

    </script>
  </head>
  <body>
    <div class="header"><div class="header-content">borogove &middot; settings &middot; about</div></div>
    <div id="text" tabindex="0"></div>
    <script>

      const edit_box = document.getElementById("text");
      const valid_ch = /^[ -~]$/; // stupid anglo-centric character set
      const split_ch = /\s+/; // delimiters
      
      let prev_tx = ''; // the text in the input area that's been
      // processed so far.
      
      let live_tx = ''; // the text in the input area that hasn't yet
      // been processed. usually the last line but
      // there are awful edge cases.

      let in_word = false;
      
      let m_model = make_markov(2);

      edit_box.addEventListener('keydown', e => {
	  
	  const k = e.key.toUpperCase();
	  let action = true
	  
	  if (k === 'ENTER') {
	      // entered a newline.
	      live_tx += '\n';
	      
	  } else if (k === 'BACKSPACE' || k === 'DELETE') {
	      // deleted a character.

	      // this much slicing cannot be good for my health
	      if (live_tx.length) {
		  live_tx = live_tx.slice(0, -1);
	      } else {
		  prev_tx = prev_tx.slice(0, -1);
		  in_word = prev_tx.length && !split_ch.test(prev_tx[prev_tx.length-1]);
	      }

	  } else if (valid_ch.test(k)) {
	      // entered a printable ascii character.
	      live_tx += k;
	      
	  } else {
	      action = false;
	      console.log(k);
	  }
	 	  
  	  edit_box.innerHTML = prev_tx + '<span style="color:#f00">' + live_tx  + '_</span>';

	  
	  if (action) {
	      e.preventDefault();
	      edit_box.scrollTop = edit_box.scrollHeight - edit_box.clientHeight;
	  }

      });


      function add_to_model () {

	  let depth = m_model.level;
	  let tail = [];

	  // try out best to grab some context off the end of what's
	  // already processed. hopefully this loop usually runs, like, once.
	  for (let backcount = 128; ; backcount *= 2) {
	      
	      tail = prev_tx
		  .slice(-backcount)
		  .split(split_ch).filter(w => w !== '');
	      
	      if (tail.length >= depth + 1) { // fricking off-by-one errors
		  tail = tail.slice(-depth);
		  break;
	      } else if (backcount > prev_tx.length) {
		  break;
	      }
	  }
	  let head = live_tx.split(split_ch).filter(w => w !== '');

	  if (tail.length + head.length - (in_word ? 1 : 0) < depth + 1) {
	      // if we don't have enough content yet, wait.
	      console.log('wait.');
	  } else {
	      // if we've cut a word in half, paste it back together
	      // before adding it to the model.
	      let i = 0;
	      if (in_word) {
		  tail[tail.length-1] += head[0];
		  ++i;
		  console.log('recover word: ' + tail[tail.length-1]);
	      }
	      for (; i < head.length; ++i) { tail.push(head[i]); }

	      // add to model:
	      markov_push(m_model, tail);
	      
	      in_word = false;
	      
	      prev_tx += live_tx;
	      live_tx = '';
	  }

      }
      
    </script>
  </body>
</html>
