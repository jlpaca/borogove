<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>borogove</title>
    <style>
      *, *:before, *:after {
	  box-sizing: inherit;
      }
      body {
	  box-sizing: border-box;
	  margin: 0;
	  position: relative;

	  color: #444;
	  background-color: #f0f0f0;

	  min-height: 100vh;
	  
	  font-family: sans-serif;
      }
      .header {
	  width: 100%;
	  height: 2em;
	  
	  display: table;
	  color: #ccc;
	  border-bottom: 1px solid #ccc;
      }
      .header-content {
	  display: table-cell;
	  padding: 0 1em;
	  vertical-align: middle;
      }

      #text {

	  color: inherit;
	  background-color: inherit;
	  font-family: inherit;
	  
	  margin: none;
	  border: none;
	  outline: none;
	  box-shadow: none;
	  
	  width: 100%;
	  height: 100vh;
	  padding: 2em 1em;

	  text-transform: uppercase;
      }
      #text::selection {
	  background: #444;
	  color: #fff;
      }
    </style>
    <script>

      let corpus = {
	  alice: [],
	  kjb: [],
	  dante: [],
      };
      /*
      for (let k in corpus) {
	  fetch('http://localhost:8000/corpus/' + k + '.json')
	      .then(resp => resp.json())
	      .then(json => { corpus[k] = json; });	    
      }
      */
      corpus.toy = [
	  "THIS", "IS", "A", "CAT.",
	  "THIS", "IS", "NOT", "A", "BAT."
      ];
      
      function make_leaf () {
	  let el = Object.create(null);
	  el.total = 0;
	  el.next = Object.create(null);
	  return el;
      }

      function make_markov (lvl) {
	  let m = Object.create(null);
	  m.level = lvl;
	  m.tree = make_leaf();
	  return m;
      }

      function markov_push (m, arr) {
	  for (let i = m.level; i < arr.length; ++i) {
	      let node = m.tree;
	      let w;

	      for (j = i-m.level; j <= i; ++j) {
		  w = arr[j];
		  ++node.total;
		  node = (node.next[w] = node.next[w] || make_leaf());
	      }
	      ++node.total;
	  }
	  return m;
      }

      function markov_select (leaf) {
	  let r = Math.random() * leaf.total;
	  let s = 0;
	  for (let w in leaf.next) {
	      if ((s += leaf.next[w].total) > r) { return w; }
	  }
      }

      function markov_step (m, tail, depth) {
	  let len = tail.length;
	  if (depth === undefined) { depth = m.level; }
	  depth = Math.min(depth, len);

	  let node = m.tree;
	  let w;
	  for (let j = len - depth; j < len; ++j) {
	      w = tail[j];
	      if (!node.next[w]) {
		  /* if terminated; try with shorter inference */
		  return markov_step(m, tail, depth-1);
	      }
	      node = node.next[w];
	  }
	  tail.push(markov_select(node));
	  return tail;
      }

    </script>
  </head>
  <body>
    <div class="header"><div class="header-content">borogove &middot; about</div></div>
    <textarea id="text">SOME TEXT</textarea>
    <script>

      let t_limit = 1000;
      let t_increment = 500;
      let timer;
      
      const D = document.getElementById("text");
      let T = undefined;
      let A = undefined;
      
      
      function autowrite_start () {
	  console.log("start autowrite:");

	  /* build the markov chain out of the text entered so
	   far. ideally we would want to dynamically update this as
	   the user types, but, i mean, have you tried keeping track
	   of input events? */

	  let words = D.value.toUpperCase().split(/\s+/).filter(w => w != '');

	  let M = make_markov(2);

	  if (words.length < M.level) {
	      /* not enough words yet, abort */
	      return;
	  }

	  markov_push(M, words);

	  A = {
	      markov: M,
	      tail: words.slice(-M.level),
	      interval: window.setInterval(() => {
		  markov_step(A.markov, A.tail, A.markov.level);
		  console.log(A.tail[A.tail.length-1]);
	      }, t_increment)
	  };
      }

      function autowrite_stop () {
	  console.log("stop autowrite.");
	  if (A) {
	      window.clearInterval(A.interval);
	  }
      }
      
      D.addEventListener('input', e => {
	  autowrite_stop();

	  if (timer) { window.clearTimeout(timer); }
	  timer = window.setTimeout(autowrite_start, t_limit);
      });

      
    </script>
  </body>
</html>
